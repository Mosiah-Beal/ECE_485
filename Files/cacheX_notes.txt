//////////////////////////////////////////////
// LRU for 8-way set associative cache. Counts down from 7 to 0 depending on the order of access
// Duplicate the structure of the cache lines from the explanation pdf
/*
integer ways = 8;					// 8 way set associative cache
reg [5:0] Tag[ways-1:0];			// 6 bits for tag (index in the example)
reg [2:0] LRU[ways-1:0];			// 3 bits for indexing the 8 ways
reg [1:0] MESI_bits[ways-1:0];		// 2 bits for MESI states (00, 01, 10, 11) (Invalid, Shared, Exclusive, Modified)

// Cache lines structure
// 	[Tag0], [Tag1], [Tag2], [Tag3], [Tag4], [Tag5], [Tag6], [Tag7]
//	[LRU0], [LRU1], [LRU2], [LRU3], [LRU4], [LRU5], [LRU6], [LRU7]	// 000 is least recently used, 111 is most recently used
//	[MESI_bits0], [MESI_bits1], [MESI_bits2], [MESI_bits3], [MESI_bits4], [MESI_bits5], [MESI_bits6], [MESI_bits7]

cache_lines [2:0][ways-1:0] = {Tag, LRU, MESI_bits};

// Accessing an element will update the LRU
// If a write miss occurs, the LRU way is selected for replacement
// if the replaced line is modified, it is written back to memory before the new line is written

// reg [31:0] address = 32'h984DE132;
// reg [11:0] tag = address[31:20]; 		// 12 bits for tag. // 1001 1000 0100b = 0x984h
// reg [13:0] set_index = address[19:6];	// 14 bits for set index. // 1101 1110 0001 00b = 0x3784h
// reg [5:0] byte_offset = address[5:0];	// 6 bits for byte offset. // 11 0010b = 0x32h

*/
//////////////////////////////////////////////


Creating an address
//////////////////////////////////////////////
// Address struct, unpacks 32-bit address into tag, set index, and byte offset
typedef struct packed {
	reg [11:0] tag;         // 12 bits for tag
	reg [13:0] set_index;   // 14 bits for set index
	reg [5:0]  byte_offset; // 6 bits for byte offset
} address_t;

// Now you can declare an address like this and assign a value to it:
address_t my_address = 32'h984DE132;

// The packed struct will automatically unpack the 32-bit address into the 3 fields
$display("tag = %h, set_index = %h, byte_offset = %h", my_address.tag, my_address.set_index, my_address.byte_offset);
//////////////////////////////////////////////

Creating a processor instruction
//////////////////////////////////////////////
// Processor instruction struct, contains instruction, address, and processor ID
typedef struct packed {
    reg[3:0] n;             // instruction
    address_t address;      // 32-bit address
    reg[2:0] PID;           // processor id
    logic[1:0] cache_num;   // which instruction cache
} processor_instruction_t processor;

// Pass in a write instruction (n=1), the first address of p1, and the PID of p1.
processor test_instruction = {1, p1addresses[0], 1};
//////////////////////////////////////////////

Creating a cache
//////////////////////////////////////////////
// Cache line struct, contains tag, LRU, MESI bits, and data
typedef struct packed {
	reg [11:0] tag;         // 12 bits for tag
	reg [2:0] LRU;          // 3 bits for LRU
	reg [1:0] MESI_bits;    // 2 bits for MESI states
	reg [511:0] data        // 512 bits for data
} cache_line_t;

// Define the number of ways for data cache
parameter ways = 8;
parameter sets = 16384; //16k = 2^14

// Declare the cache as an array of cache lines
cache_line_t data_cache[sets-1][ways-1:0];   // L1 data cache

// Initialize the cache !!! note initialization for each set needs to be added !!!
initial begin
    // Initialize each set
    for(int i = 0; i < sets; i++) begin
        // Initialize each way
        for(int j = 0; j < ways; j++) begin
            data_cache[i][j].LRU = j;           // LRU = way of the cache line (0, 1, 2, 3, 4, 5, 6, 7)
            data_cache[i][j].MESI_bits = 2'b00; // Initialize MESI bits to Invalid
            data_cache[i][j].tag = 6'b0;        // Initialize tag to 0
            data_cache[i][j].data = 512'b0      // Initialize mem to 0
        end
    end
end
//////////////////////////////////////////////

